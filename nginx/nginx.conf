worker_processes  4;

env SOCKEXEC_SOCKET;
env DATA_DIR;


events {
    worker_connections  1024;
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  sendfile        on;

  keepalive_timeout  65;

  lua_package_path "/usr/local/openresty/site/lualib/boxes/?.lua;/usr/local/openresty/nginx/lua/?.lua;;";

  init_worker_by_lua_block {
    uuid = require 'resty.jit-uuid'
    uuid.seed()
  }

  init_by_lua_block {
    require "resty.core"
    collectgarbage("collect")  -- just to collect any garbage
    inspect = require('inspect')
    classifier = require('classifier')
    object = require('object')
    encodeJSON = require('cjson.safe').encode
    decodeJSON = require('cjson.safe').decode
    prog = require 'resty.exec'.new(os.getenv("SOCKEXEC_SOCKET"))
    DATA_DIR = os.getenv("DATA_DIR") .. "/"

    convert2pnm = function(image_path)
      local cmd = { "convert", image_path, "pnm:" .. image_path }
      return prog({
        argv = cmd,
        timeout_fatal = false
      })
    end

    image2ocr = function(image_path, type)
      local cmd = { "/usr/bin/tesseract", "-l", "eng+rus", image_path, "stdout" }
      if type == "gocr" then
        local res, err = convert2pnm(image_path)
        if err ~= nil   then
          return res, err
        end
        cmd = { "/usr/local/bin/gocr", image_path }
      end

      ngx.log(ngx.ERR, "Output filename: " .. inspect(cmd))

      --local prog = require 'resty.exec'.new(os.getenv("SOCKEXEC_SOCKET"))
      return prog({
        argv = cmd,
        timeout_fatal = false
      })

    end
  }

  resolver 127.0.0.11;

  server {
      listen       80;
      server_name  localhost;


       location /upload {
            content_by_lua '
                local upload = require "resty.upload"
                local cjson = require "cjson"
                local out_filename = DATA_DIR .. uuid()
                local output = io.open(out_filename, "wb")

                if output == nil then
                  ngx.status = ngx.ERROR
                  ngx.say(encodeJSON({
                    error = "io.open",
                  }))
                  ngx.exit(ngx.ERROR)
                end

                local chunk_size = 8192 -- should be set to 4096 or 8192
                                     -- for real-world settings

                local form, err = upload:new(chunk_size)
                if not form then
                    ngx.log(ngx.ERR, "failed to new upload: ", err)
                    ngx.exit(500)
                end

                form:set_timeout(1000) -- 1 sec

                while true do
                    local typ, res, err = form:read()
                    if not typ then
                        ngx.say("failed to read: ", err)
                        return
                    end

                    if typ == "body" then
                      --ngx.say("BODY: ", cjson.encode({typ, res}))
                      output:write(res)
                    end

                    if typ == "eof" then
                        break
                    end
                end

                local typ, res, err = form:read()
                output:close()

                local res, err = image2ocr(out_filename, ngx.var.arg_ocr_engine)
                if err == nil then
                  ngx.say(res.stdout)
                end


                os.remove(out_filename)
            ';
      }

      location /classifier {
        content_by_lua_block {

          local upload = require "resty.upload"
          local out_filename = DATA_DIR .. uuid() .. "_text"
          local output = io.open(out_filename, "wb")

          if output == nil then
            ngx.say(encodeJSON({
              error = "io.open",
            }))
            ngx.exit(ngx.ERROR)
          end

          local chunk_size = 8192 -- should be set to 4096 or 8192
                               -- for real-world settings

          local form, err = upload:new(chunk_size)
          if not form then
              ngx.log(ngx.ERR, "failed to new upload: ", err)
              ngx.exit(500)
          end

          form:set_timeout(1000) -- 1 sec

          while true do
              local typ, res, err = form:read()
              if not typ then
                  ngx.say("failed to read: ", err)
                  return
              end

              if typ == "body" then
                output:write(res)
              end

              if typ == "eof" then
                  break
              end
          end

          local typ, res, err = form:read()
          output:close()


          local objects = classifier:parse(prog, out_filename)
          os.remove(out_filename)
          ngx.say('{ "objects": [' .. objects .. ']}' )
        }
      }

      location /object {
        content_by_lua_block {
          ngx.req.read_body()
          local object_list = decodeJSON(ngx.var.request_body)
          ngx.log(ngx.ERR, "Output filename: " .. inspect(object_list["objects"]))
          local objects = object:parse(object_list)
          ngx.say(encodeJSON(objects))
          --ngx.say("OK")
        }
      }


      location /ping {
        content_by_lua_block {
          ngx.say(encodeJSON({
            pong = "true",
          }))
        }
      }

      location / {
          root   /usr/local/openresty/nginx/html;
          index  index.html index.htm;
      }

  }

}
